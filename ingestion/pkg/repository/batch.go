// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: batch.go

package repository

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const createCnaeBatch = `-- name: CreateCnaeBatch :batchexec
INSERT INTO cnaes (
    codigo,
    descricao
) VALUES (
    $1, $2
)
`

type CreateCnaeBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateCnaeBatchParams struct {
	Codigo    string
	Descricao pgtype.Text
}

func (q *Queries) CreateCnaeBatch(ctx context.Context, arg []CreateCnaeBatchParams) *CreateCnaeBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Codigo,
			a.Descricao,
		}
		batch.Queue(createCnaeBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateCnaeBatchBatchResults{br, len(arg), false}
}

func (b *CreateCnaeBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateCnaeBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createEmpresaBatch = `-- name: CreateEmpresaBatch :batchexec
INSERT INTO empresas (
    cnpj_basico,
    razao_social,
    natureza_juridica,
    qualificacao_responsavel,
    capital_social,
    porte,
    ente_federativo_responsavel
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
`

type CreateEmpresaBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateEmpresaBatchParams struct {
	CnpjBasico                string
	RazaoSocial               pgtype.Text
	NaturezaJuridica          pgtype.Text
	QualificacaoResponsavel   pgtype.Text
	CapitalSocial             pgtype.Numeric
	Porte                     pgtype.Text
	EnteFederativoResponsavel pgtype.Text
}

func (q *Queries) CreateEmpresaBatch(ctx context.Context, arg []CreateEmpresaBatchParams) *CreateEmpresaBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.CnpjBasico,
			a.RazaoSocial,
			a.NaturezaJuridica,
			a.QualificacaoResponsavel,
			a.CapitalSocial,
			a.Porte,
			a.EnteFederativoResponsavel,
		}
		batch.Queue(createEmpresaBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateEmpresaBatchBatchResults{br, len(arg), false}
}

func (b *CreateEmpresaBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateEmpresaBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createEstabelecimentoBatch = `-- name: CreateEstabelecimentoBatch :batchexec
INSERT INTO estabelecimentos (
    cnpj_basico,
    cnpj_ordem,
    cnpj_dv,
    identificador_matriz_filial,
    nome_fantasia,
    situacao_cadastral,
    data_situacao_cadastral,
    motivo_situacao_cadastral,
    nome_cidade_exterior,
    pais,
    data_inicio_atividade,
    cnae_fiscal_principal,
    cnae_fiscal_secundaria,
    tipo_logradouro,
    logradouro,
    numero,
    complemento,
    bairro,
    cep,
    uf,
    municipio,
    ddd_1,
    telefone_1,
    ddd_2,
    telefone_2,
    ddd_fax,
    fax,
    correio_eletronico,
    situacao_especial,
    data_situacao_especial
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
    $21, $22, $23, $24, $25, $26, $27, $28, $29, $30
)
`

type CreateEstabelecimentoBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateEstabelecimentoBatchParams struct {
	CnpjBasico                string
	CnpjOrdem                 string
	CnpjDv                    string
	IdentificadorMatrizFilial pgtype.Text
	NomeFantasia              pgtype.Text
	SituacaoCadastral         pgtype.Text
	DataSituacaoCadastral     pgtype.Date
	MotivoSituacaoCadastral   pgtype.Text
	NomeCidadeExterior        pgtype.Text
	Pais                      pgtype.Text
	DataInicioAtividade       pgtype.Date
	CnaeFiscalPrincipal       pgtype.Text
	CnaeFiscalSecundaria      pgtype.Text
	TipoLogradouro            pgtype.Text
	Logradouro                pgtype.Text
	Numero                    pgtype.Text
	Complemento               pgtype.Text
	Bairro                    pgtype.Text
	Cep                       pgtype.Text
	Uf                        pgtype.Text
	Municipio                 pgtype.Text
	Ddd1                      pgtype.Text
	Telefone1                 pgtype.Text
	Ddd2                      pgtype.Text
	Telefone2                 pgtype.Text
	DddFax                    pgtype.Text
	Fax                       pgtype.Text
	CorreioEletronico         pgtype.Text
	SituacaoEspecial          pgtype.Text
	DataSituacaoEspecial      pgtype.Date
}

func (q *Queries) CreateEstabelecimentoBatch(ctx context.Context, arg []CreateEstabelecimentoBatchParams) *CreateEstabelecimentoBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.CnpjBasico,
			a.CnpjOrdem,
			a.CnpjDv,
			a.IdentificadorMatrizFilial,
			a.NomeFantasia,
			a.SituacaoCadastral,
			a.DataSituacaoCadastral,
			a.MotivoSituacaoCadastral,
			a.NomeCidadeExterior,
			a.Pais,
			a.DataInicioAtividade,
			a.CnaeFiscalPrincipal,
			a.CnaeFiscalSecundaria,
			a.TipoLogradouro,
			a.Logradouro,
			a.Numero,
			a.Complemento,
			a.Bairro,
			a.Cep,
			a.Uf,
			a.Municipio,
			a.Ddd1,
			a.Telefone1,
			a.Ddd2,
			a.Telefone2,
			a.DddFax,
			a.Fax,
			a.CorreioEletronico,
			a.SituacaoEspecial,
			a.DataSituacaoEspecial,
		}
		batch.Queue(createEstabelecimentoBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateEstabelecimentoBatchBatchResults{br, len(arg), false}
}

func (b *CreateEstabelecimentoBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateEstabelecimentoBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createMotivoBatch = `-- name: CreateMotivoBatch :batchexec
INSERT INTO motivos (
    codigo,
    descricao
) VALUES (
    $1, $2
)
`

type CreateMotivoBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateMotivoBatchParams struct {
	Codigo    string
	Descricao pgtype.Text
}

func (q *Queries) CreateMotivoBatch(ctx context.Context, arg []CreateMotivoBatchParams) *CreateMotivoBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Codigo,
			a.Descricao,
		}
		batch.Queue(createMotivoBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateMotivoBatchBatchResults{br, len(arg), false}
}

func (b *CreateMotivoBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateMotivoBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createMunicipioBatch = `-- name: CreateMunicipioBatch :batchexec
INSERT INTO municipios (
    codigo,
    descricao
) VALUES (
    $1, $2
)
`

type CreateMunicipioBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateMunicipioBatchParams struct {
	Codigo    string
	Descricao pgtype.Text
}

func (q *Queries) CreateMunicipioBatch(ctx context.Context, arg []CreateMunicipioBatchParams) *CreateMunicipioBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Codigo,
			a.Descricao,
		}
		batch.Queue(createMunicipioBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateMunicipioBatchBatchResults{br, len(arg), false}
}

func (b *CreateMunicipioBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateMunicipioBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createNaturezaJuridicaBatch = `-- name: CreateNaturezaJuridicaBatch :batchexec
INSERT INTO naturezas_juridicas (
    codigo,
    descricao
) VALUES (
    $1, $2
)
`

type CreateNaturezaJuridicaBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateNaturezaJuridicaBatchParams struct {
	Codigo    string
	Descricao pgtype.Text
}

func (q *Queries) CreateNaturezaJuridicaBatch(ctx context.Context, arg []CreateNaturezaJuridicaBatchParams) *CreateNaturezaJuridicaBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Codigo,
			a.Descricao,
		}
		batch.Queue(createNaturezaJuridicaBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateNaturezaJuridicaBatchBatchResults{br, len(arg), false}
}

func (b *CreateNaturezaJuridicaBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateNaturezaJuridicaBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createPaisBatch = `-- name: CreatePaisBatch :batchexec
INSERT INTO paises (
    codigo,
    descricao
) VALUES (
    $1, $2
)
`

type CreatePaisBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreatePaisBatchParams struct {
	Codigo    string
	Descricao pgtype.Text
}

func (q *Queries) CreatePaisBatch(ctx context.Context, arg []CreatePaisBatchParams) *CreatePaisBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Codigo,
			a.Descricao,
		}
		batch.Queue(createPaisBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreatePaisBatchBatchResults{br, len(arg), false}
}

func (b *CreatePaisBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreatePaisBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createQualificacaoSocioBatch = `-- name: CreateQualificacaoSocioBatch :batchexec
INSERT INTO qualificacoes_de_socios (
    codigo,
    descricao
) VALUES (
    $1, $2
)
`

type CreateQualificacaoSocioBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateQualificacaoSocioBatchParams struct {
	Codigo    string
	Descricao pgtype.Text
}

func (q *Queries) CreateQualificacaoSocioBatch(ctx context.Context, arg []CreateQualificacaoSocioBatchParams) *CreateQualificacaoSocioBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Codigo,
			a.Descricao,
		}
		batch.Queue(createQualificacaoSocioBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateQualificacaoSocioBatchBatchResults{br, len(arg), false}
}

func (b *CreateQualificacaoSocioBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateQualificacaoSocioBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createSimplesBatch = `-- name: CreateSimplesBatch :batchexec
INSERT INTO simples (
    cnpj_basico,
    opcao_pelo_simples,
    data_opcao_pelo_simples,
    data_exclusao_do_simples,
    opcao_pelo_mei,
    data_opcao_pelo_mei,
    data_exclusao_do_mei
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
`

type CreateSimplesBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateSimplesBatchParams struct {
	CnpjBasico            string
	OpcaoPeloSimples      pgtype.Text
	DataOpcaoPeloSimples  pgtype.Date
	DataExclusaoDoSimples pgtype.Date
	OpcaoPeloMei          pgtype.Text
	DataOpcaoPeloMei      pgtype.Date
	DataExclusaoDoMei     pgtype.Date
}

func (q *Queries) CreateSimplesBatch(ctx context.Context, arg []CreateSimplesBatchParams) *CreateSimplesBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.CnpjBasico,
			a.OpcaoPeloSimples,
			a.DataOpcaoPeloSimples,
			a.DataExclusaoDoSimples,
			a.OpcaoPeloMei,
			a.DataOpcaoPeloMei,
			a.DataExclusaoDoMei,
		}
		batch.Queue(createSimplesBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateSimplesBatchBatchResults{br, len(arg), false}
}

func (b *CreateSimplesBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateSimplesBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createSocioBatch = `-- name: CreateSocioBatch :batchexec
INSERT INTO socios (
    cnpj_basico,
    identificador_de_socio,
    nome_socio,
    cnpj_cpf_socio,
    qualificacao_socio,
    data_entrada_sociedade,
    pais,
    representante_legal,
    nome_representante,
    qualificacao_representante_legal,
    faixa_etaria
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
`

type CreateSocioBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateSocioBatchParams struct {
	CnpjBasico                     pgtype.Text
	IdentificadorDeSocio           pgtype.Text
	NomeSocio                      pgtype.Text
	CnpjCpfSocio                   pgtype.Text
	QualificacaoSocio              pgtype.Text
	DataEntradaSociedade           pgtype.Date
	Pais                           pgtype.Text
	RepresentanteLegal             pgtype.Text
	NomeRepresentante              pgtype.Text
	QualificacaoRepresentanteLegal pgtype.Text
	FaixaEtaria                    pgtype.Text
}

func (q *Queries) CreateSocioBatch(ctx context.Context, arg []CreateSocioBatchParams) *CreateSocioBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.CnpjBasico,
			a.IdentificadorDeSocio,
			a.NomeSocio,
			a.CnpjCpfSocio,
			a.QualificacaoSocio,
			a.DataEntradaSociedade,
			a.Pais,
			a.RepresentanteLegal,
			a.NomeRepresentante,
			a.QualificacaoRepresentanteLegal,
			a.FaixaEtaria,
		}
		batch.Queue(createSocioBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateSocioBatchBatchResults{br, len(arg), false}
}

func (b *CreateSocioBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateSocioBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
