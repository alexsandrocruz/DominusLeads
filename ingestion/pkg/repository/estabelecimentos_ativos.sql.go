// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: estabelecimentos_ativos.sql

package repository

import (
	"context"
)

const getEstabelecimentosAtivosByMunicipioAndCnae = `-- name: GetEstabelecimentosAtivosByMunicipioAndCnae :many
SELECT cnpj_basico, cnpj_ordem, cnpj_dv, identificador_matriz_filial, nome_fantasia, situacao_cadastral, data_situacao_cadastral, motivo_situacao_cadastral, nome_cidade_exterior, pais, data_inicio_atividade, cnaes, tipo_logradouro, logradouro, numero, complemento, bairro, cep, uf, municipio, ddd_1, telefone_1, ddd_2, telefone_2, ddd_fax, fax, correio_eletronico, situacao_especial, data_situacao_especial FROM estabelecimentos_ativos WHERE municipio = $1::text AND cnaes @> $2::text[] LIMIT 10
`

type GetEstabelecimentosAtivosByMunicipioAndCnaeParams struct {
	Municipio string
	Cnaes     []string
}

func (q *Queries) GetEstabelecimentosAtivosByMunicipioAndCnae(ctx context.Context, arg GetEstabelecimentosAtivosByMunicipioAndCnaeParams) ([]EstabelecimentosAtivo, error) {
	rows, err := q.db.Query(ctx, getEstabelecimentosAtivosByMunicipioAndCnae, arg.Municipio, arg.Cnaes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EstabelecimentosAtivo
	for rows.Next() {
		var i EstabelecimentosAtivo
		if err := rows.Scan(
			&i.CnpjBasico,
			&i.CnpjOrdem,
			&i.CnpjDv,
			&i.IdentificadorMatrizFilial,
			&i.NomeFantasia,
			&i.SituacaoCadastral,
			&i.DataSituacaoCadastral,
			&i.MotivoSituacaoCadastral,
			&i.NomeCidadeExterior,
			&i.Pais,
			&i.DataInicioAtividade,
			&i.Cnaes,
			&i.TipoLogradouro,
			&i.Logradouro,
			&i.Numero,
			&i.Complemento,
			&i.Bairro,
			&i.Cep,
			&i.Uf,
			&i.Municipio,
			&i.Ddd1,
			&i.Telefone1,
			&i.Ddd2,
			&i.Telefone2,
			&i.DddFax,
			&i.Fax,
			&i.CorreioEletronico,
			&i.SituacaoEspecial,
			&i.DataSituacaoEspecial,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
